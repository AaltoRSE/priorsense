% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerscale.R, R/powerscale_gradients.R,
%   R/powerscale_sensitivity.R, R/powerscale_sequence.R
\name{powerscale-overview}
\alias{powerscale-overview}
\alias{powerscale}
\alias{powerscale.powerscaling_data}
\alias{powerscale.default}
\alias{powerscale.CmdStanFit}
\alias{powerscale.brmsfit}
\alias{powerscale.stanfit}
\alias{powerscale_gradients.powerscaling_data}
\alias{powerscale_gradients.CmdStanFit}
\alias{powerscale_gradients.default}
\alias{powerscale_sensitivity.default}
\alias{powerscale_sensitivity.powerscaling_data}
\alias{powerscale_sensitivity.CmdStanFit}
\alias{powerscale_sensitivity.stanfit}
\alias{powerscale_sensitivity.brmsfit}
\alias{powerscale_sequence}
\alias{powerscale_sequence.powerscaling_data}
\alias{powerscale_sequence.CmdStanFit}
\alias{powerscale_sequence.stanfit}
\alias{powerscale_sequence.brmsfit}
\alias{powerscale_sequence.default}
\title{Prior/likelihood power-scaling perturbation}
\usage{
powerscale(x, ...)

\method{powerscale}{powerscaling_data}(x, alpha, ...)

\method{powerscale}{default}(
  x,
  alpha,
  log_prior_fn,
  joint_log_lik_fn,
  get_draws,
  unconstrain_pars,
  log_prob_upars,
  log_ratio_upars,
  variable = NULL,
  component = "prior",
  is_method = "psis",
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = FALSE,
  prediction = NULL,
  ...
)

\method{powerscale}{CmdStanFit}(x, ...)

\method{powerscale}{brmsfit}(x, ...)

\method{powerscale}{stanfit}(x, ...)

\method{powerscale_gradients}{powerscaling_data}(x, ...)

\method{powerscale_gradients}{CmdStanFit}(x, ...)

\method{powerscale_gradients}{default}(
  x,
  get_draws,
  unconstrain_pars,
  log_prob_upars,
  log_ratio_upars,
  variable = NULL,
  component = c("prior", "likelihood"),
  type = c("quantities", "divergence"),
  lower_alpha = 0.99,
  upper_alpha = 1.01,
  div_measure = "cjs_dist",
  measure_args = list(),
  is_method = "psis",
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = FALSE,
  prediction = NULL,
  scale = FALSE,
  ...
)

\method{powerscale_sensitivity}{default}(x, ...)

\method{powerscale_sensitivity}{powerscaling_data}(
  x,
  variable = NULL,
  lower_alpha = 0.9,
  upper_alpha = 1.1,
  div_measure = "cjs_dist",
  measure_args = list(),
  component = c("prior", "likelihood"),
  sensitivity_threshold = 0.05,
  is_method = "psis",
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = FALSE,
  prediction = NULL,
  ...
)

\method{powerscale_sensitivity}{CmdStanFit}(x, ...)

\method{powerscale_sensitivity}{stanfit}(x, ...)

\method{powerscale_sensitivity}{brmsfit}(x, ...)

powerscale_sequence(x, ...)

\method{powerscale_sequence}{powerscaling_data}(
  x,
  lower_alpha = 0.5,
  upper_alpha = 1/lower_alpha,
  alpha_step = 0.1,
  variable = NULL,
  component = c("prior", "likeliood"),
  ...
)

\method{powerscale_sequence}{CmdStanFit}(
  x,
  lower_alpha = 0.5,
  upper_alpha = 1/lower_alpha,
  alpha_step = 0.1,
  variable = NULL,
  component = c("prior", "likeliood"),
  ...
)

\method{powerscale_sequence}{stanfit}(
  x,
  lower_alpha = 0.5,
  upper_alpha = 1/lower_alpha,
  alpha_step = 0.1,
  variable = NULL,
  component = c("prior", "likelihood"),
  ...
)

\method{powerscale_sequence}{brmsfit}(x, ...)

\method{powerscale_sequence}{default}(
  x,
  lower_alpha = 0.5,
  upper_alpha = 1/lower_alpha,
  alpha_step = 0.1,
  variable = NULL,
  component = c("prior", "likelihood"),
  is_method = "psis",
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  log_prior_fn,
  joint_log_lik_fn,
  transform = FALSE,
  get_draws,
  ...
)
}
\arguments{
\item{x}{A fitted model object of class \code{stanfit}, \code{brmsfit} or
\code{CmdStanFit}.}

\item{...}{Further arguments passed to the custom functions
documented above.}

\item{alpha}{Value by which to power-scale specified
component. (likelihood/prior).}

\item{log_prior_fn}{A function that takes as input the model fit
and returns the log prior values.}

\item{joint_log_lik_fn}{A function that takes as input the model
fit and returns the joint log likelihood values.}

\item{variable}{Vector of variable names to return estimated
posterior draws for.}

\item{component}{Component to be power-scaled (either "prior" or
"likelihood"). For powerscale_sequence, this can be both "prior"
and "likelihood".}

\item{is_method}{The importance sampling method to use. The
following methods are available:
\itemize{
\item \code{"psis"}: Pareto-Smoothed Importance Sampling (PSIS). Default
method.
\item \code{"tis"}: Truncated Importance Sampling (TIS) with truncation at
\code{sqrt(S)}, where \code{S} is the number of posterior draws.
\item \code{"sis"}: Standard Importance Sampling (SIS).
}

For further details, see the \code{loo} package.}

\item{moment_match}{Logical; Indicate whether or not moment
matching should be performed. Can only be TRUE if \code{is_method} is
"psis".}

\item{k_threshold}{Threshold value for Pareto k values above which
the moment matching algorithm is used. Default is 0.5.}

\item{resample}{Logical; Indicate whether or not draws should be
resampled based on calculated importance weights.}

\item{transform}{Indicate transformation of posterior
draws. Either "scale" or "spherize".}

\item{prediction}{Function taking the model fit and returning a
draws_df of predictions to be appended to the posterior draws}

\item{lower_alpha}{Lower power-scaling alpha value in sequence.}

\item{upper_alpha}{Upper power-scaling alpha value in sequence.}

\item{alpha_step}{Step size of power-scaling alphas in sequence.}
}
\value{
A \code{powerscaled_draws} or \code{powerscaled_sequence} object,
which contains the estimated posterior draws resulting from the
power-scaling perturbations and details of the perturbation and
estimation methods.
}
\description{
Estimate posterior draws based on power-scaling perturbations of
prior or likelihood using importance sampling (and optionally moment matching).
}
\references{
Kallioinen, N., Paananen, T., Bürkner, P-C., Vehtari, A. (in
prep).  Detecting and diagnosing prior and likelihood sensitivity
with power-scaling perturbations.

Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry,
J. (2019).  Pareto smoothed importance sampling.  \href{https://arxiv.org/abs/1507}{preprint arXiv:1507.02646}

Paananen, T., Piironen, J., Bürkner, P-C., Vehtari, A. (2021).
Implicitly adaptive importance sampling.  \emph{Statistics and
Computing}. 31(16).  \code{doi:10.1007/s11222-020-09982-2}
}
